import { Request, Response } from 'express';
import mongoose from 'mongoose';
import { Universidad } from '../models/Universidad';
import { Titulacion } from '../models/Titulacion';
import { Contacto } from '../models/Contacto';
import { Usuario } from '../models/Usuario';
import { JerarquiaUsuarios } from '../models/JerarquiaUsuarios'; // RESTAURADO
import { AuditLog, EntidadAudit, AccionAudit } from '../models/AuditLog';
import { AuthRequest, RolUsuario } from '../types';

export class UniversidadesController {
  // Obtener todas las universidades
  static async obtenerUniversidades(req: AuthRequest, res: Response) {
    try {
      const { 
        page = 1, 
        limit = 10, 
        search, 
        activa // No filtrar por defecto, mostrar todas
      } = req.query;

      const skip = (Number(page) - 1) * Number(limit);
      const filter: any = {};

      // Aplicar filtros
      if (search) {
        filter.$or = [
          { nombre: { $regex: search, $options: 'i' } },
          { codigo: { $regex: search, $options: 'i' } }
        ];
      }

      // Filtrar por activa solo si se especifica el par√°metro
      if (activa !== undefined) {
        filter.activa = activa === 'true';
      }

      const universidades = await Universidad.find(filter)
        .sort({ nombre: 1 })
        .skip(skip)
        .limit(Number(limit));

      // Obtener las titulaciones para cada universidad
      const universidadesConTitulaciones = await Promise.all(
        universidades.map(async (universidad) => {
          const titulaciones = await Titulacion.find({ 
            universidadId: universidad._id,
            estado: 'activa'
          }).select('nombre codigo tipo duracion creditos modalidad');
          
          return {
            ...universidad.toObject(),
            titulaciones
          };
        })
      );

      const total = await Universidad.countDocuments(filter);

      res.json({
        universidades: universidadesConTitulaciones,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total,
          pages: Math.ceil(total / Number(limit))
        }
      });
    } catch (error) {
      console.error('Error al obtener universidades:', error);
      res.status(500).json({ error: 'Error interno del servidor' });
    }
  }

  // Obtener universidad por ID
  static async obtenerUniversidad(req: AuthRequest, res: Response) {
    try {
      const { id } = req.params;
      console.log('üîç obtenerUniversidad called with ID:', id);
      console.log('üîç ID type:', typeof id);
      console.log('üîç Request params:', req.params);

      if (!mongoose.Types.ObjectId.isValid(id)) {
        console.log('‚ùå Invalid ObjectId:', id);
        return res.status(400).json({ error: 'ID de universidad inv√°lido' });
      }

      console.log('üîç Searching for universidad with ID:', id);
      const universidad = await Universidad.findById(id);
      console.log('üè´ Universidad found:', universidad ? universidad.toObject() : 'null');

      if (!universidad) {
        console.log('‚ùå Universidad not found for ID:', id);
        return res.status(404).json({ error: 'Universidad no encontrada' });
      }

      // Obtener las titulaciones de la universidad
      console.log('üîç Searching titulaciones for universidadId:', universidad._id);
      const titulaciones = await Titulacion.find({ 
        universidadId: universidad._id,
        estado: 'activa'
      }).select('nombre codigo tipo duracion creditos modalidad descripcion');
      console.log('üéì Titulaciones found:', titulaciones.length, titulaciones);

      const universidadConTitulaciones = {
        ...universidad.toObject(),
        titulaciones
      };
      console.log('üì§ Sending response:', universidadConTitulaciones);

      res.json(universidadConTitulaciones);
    } catch (error: any) {
      console.error('‚ùå Error al obtener universidad:', error);
      console.error('‚ùå Error stack:', error.stack);
      res.status(500).json({ error: 'Error interno del servidor' });
    }
  }

  // Funci√≥n para normalizar nombres (eliminar acentos y convertir a min√∫sculas)
  private static normalizeName(name: string): string {
    return name
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Eliminar acentos
      .trim();
  }

  private static normalizeNameWithCapitalization(name: string): string {
    const normalized = name
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Eliminar acentos
      .trim();
    
    // Capitalizar la primera letra
    return normalized.charAt(0).toUpperCase() + normalized.slice(1);
  }

  // Normalizar todos los nombres de colegios existentes
  static async normalizarNombresColegios(req: AuthRequest, res: Response) {
    try {
      // Solo admins pueden normalizar nombres
      if (req.user?.rol !== RolUsuario.ADMIN) {
        return res.status(403).json({ 
          error: 'No tienes permisos para normalizar nombres de colegios' 
        });
      }

      console.log('üîç Iniciando normalizaci√≥n de nombres de colegios...');
      
      // Obtener todos los contactos
      const contactos = await Contacto.find({});
      console.log(`üìä Total de contactos encontrados: ${contactos.length}`);
      
      let contactosActualizados = 0;
      let errores = 0;
      const cambios: Array<{contactoId: string, nombreAnterior: string, nombreNuevo: string}> = [];
      
      for (const contacto of contactos) {
        try {
          const nombreAnterior = contacto.nombreColegio || '';
          const nombreNormalizado = this.normalizeName(nombreAnterior);
          
          // Solo actualizar si el nombre cambi√≥ al normalizar
          if (nombreAnterior !== nombreNormalizado && nombreNormalizado !== '') {
            console.log(`üîÑ Normalizando: "${nombreAnterior}" ‚Üí "${nombreNormalizado}"`);
            
            contacto.nombreColegio = nombreNormalizado;
            await contacto.save();
            
            contactosActualizados++;
            cambios.push({
              contactoId: contacto._id.toString(),
              nombreAnterior,
              nombreNuevo: nombreNormalizado
            });
          }
        } catch (error) {
          console.error(`‚ùå Error normalizando contacto ${contacto._id}:`, error);
          errores++;
        }
      }
      
      console.log(`‚úÖ Normalizaci√≥n completada: ${contactosActualizados} contactos actualizados, ${errores} errores`);
      
      // Registrar en auditor√≠a
      await AuditLog.create({
        usuarioId: new mongoose.Types.ObjectId(req.user!.userId),
        accion: AccionAudit.UPDATE,
        entidad: EntidadAudit.CONTACTO,
        entidadId: 'BULK_NORMALIZATION',
        despues: {
          accion: 'NORMALIZACION_MASIVA_NOMBRES_COLEGIOS',
          contactosActualizados,
          errores,
          cambios: cambios.slice(0, 10) // Solo los primeros 10 cambios en el log
        }
      });

      res.json({
        success: true,
        message: 'Normalizaci√≥n de nombres completada',
        contactosActualizados,
        errores,
        totalContactos: contactos.length
      });
    } catch (error) {
      console.error('Error normalizando nombres de colegios:', error);
      res.status(500).json({ 
        success: false,
        error: 'Error interno del servidor' 
      });
    }
  }

  // Crear nueva universidad
  static async crearUniversidad(req: AuthRequest, res: Response) {
    try {
      // Verificar que el usuario est√© autenticado
      if (!req.user) {
        console.log('‚ùå Usuario no autenticado');
        return res.status(401).json({ 
          error: 'Usuario no autenticado' 
        });
      }

      const { codigo, nombre, tipo, ciudad, activa } = req.body;

      console.log('üîç Datos recibidos para crear universidad:', { codigo, nombre, tipo, ciudad, activa });
      console.log('üîç Usuario que hace la petici√≥n:', { userId: req.user.userId, rol: req.user.rol });

      // Solo admins pueden crear universidades
      if (req.user.rol !== RolUsuario.ADMIN) {
        console.log('‚ùå Usuario no es administrador:', req.user.rol);
        return res.status(403).json({ 
          error: 'No tienes permisos para crear universidades' 
        });
      }

      // Validaciones
      if (!codigo || !nombre || !tipo || !ciudad) {
        console.log('‚ùå Validaci√≥n fallida - Campos faltantes:', { codigo, nombre, tipo, ciudad });
        return res.status(400).json({ 
          error: 'C√≥digo, nombre, tipo y ciudad son obligatorios' 
        });
      }

      console.log('‚úÖ Usuario es administrador, continuando...');

      // Verificar que el c√≥digo no exista
      console.log('üîç Verificando si el c√≥digo ya existe:', codigo);
      const universidadExistente = await Universidad.findOne({ codigo });
      if (universidadExistente) {
        console.log('‚ùå C√≥digo ya existe:', universidadExistente.nombre);
        return res.status(400).json({ 
          error: 'Ya existe una universidad con este c√≥digo' 
        });
      }
      console.log('‚úÖ C√≥digo disponible');

      // Crear universidad
      console.log('üîç Creando nueva universidad con datos:', { codigo, nombre, tipo, ciudad });
      const nuevaUniversidad = new Universidad({
        codigo,
        nombre,
        tipo,
        ciudad,
        activa: true, // Siempre activo
        creadoPor: new mongoose.Types.ObjectId(req.user.userId)
      });

      console.log('üíæ Guardando universidad en la base de datos...');
      await nuevaUniversidad.save();
      console.log('‚úÖ Universidad guardada exitosamente:', nuevaUniversidad._id);

      // Asociar contactos existentes con el mismo nombre normalizado
      console.log('üîç Buscando contactos para asociar con el nuevo colegio...');
      let contactosAsociados: string[] = [];
      
      try {
        const nombreNormalizado = this.normalizeName(nombre);
        console.log('üîç Nombre normalizado:', nombreNormalizado);
        
        // Buscar contactos que tengan un nombre de colegio que coincida al normalizar
        const contactosParaAsociar = await Contacto.find({});
        console.log(`üîç Encontrados ${contactosParaAsociar.length} contactos para revisar`);
        
        for (const contacto of contactosParaAsociar) {
          try {
            const nombreColegioNormalizado = this.normalizeName(contacto.nombreColegio || '');
            if (nombreColegioNormalizado === nombreNormalizado && contacto.nombreColegio !== nombre) {
              console.log(`üîó Asociando contacto ${contacto.nombreCompleto} (${contacto.nombreColegio}) con nuevo colegio ${nombre}`);
              
              // Actualizar el nombre del colegio en el contacto
              contacto.nombreColegio = nombre;
              await contacto.save();
              contactosAsociados.push(contacto._id.toString());
            }
          } catch (contactError) {
            console.error(`‚ùå Error procesando contacto ${contacto._id}:`, contactError);
            // Continue with other contacts
          }
        }
        
        console.log(`‚úÖ ${contactosAsociados.length} contactos asociados autom√°ticamente`);
      } catch (associationError) {
        console.error('‚ùå Error en asociaci√≥n de contactos:', associationError);
        // Continue without failing the university creation
        contactosAsociados = [];
      }

      // Registrar en auditor√≠a
      try {
        await AuditLog.create({
          usuarioId: new mongoose.Types.ObjectId(req.user.userId),
          accion: AccionAudit.CREATE,
          entidad: EntidadAudit.UNIVERSIDAD,
          entidadId: nuevaUniversidad._id.toString(),
          despues: {
            codigo: nuevaUniversidad.codigo,
            nombre: nuevaUniversidad.nombre,
            tipo: nuevaUniversidad.tipo,
            ciudad: nuevaUniversidad.ciudad,
            activa: nuevaUniversidad.activa,
            contactosAsociados: contactosAsociados.length
          }
        });
        console.log('‚úÖ Auditor√≠a registrada exitosamente');
      } catch (auditError) {
        console.error('‚ùå Error registrando auditor√≠a:', auditError);
        // Continue without failing the university creation
      }

      console.log('üì§ Enviando respuesta exitosa');
      res.status(201).json({ 
        message: 'Colegio creado exitosamente',
        universidad: nuevaUniversidad,
        contactosAsociados: contactosAsociados.length
      });
    } catch (error: any) {
      console.error('‚ùå Error al crear universidad:', error);
      console.error('‚ùå Error stack:', error.stack);
      console.error('‚ùå Error name:', error.name);
      console.error('‚ùå Error message:', error.message);
      
      // Check if it's a duplicate key error
      if (error.code === 11000) {
        console.log('‚ùå Error de clave duplicada detectado');
        return res.status(400).json({ 
          error: 'Ya existe una universidad con este c√≥digo o nombre' 
        });
      }
      
      res.status(500).json({ error: 'Error interno del servidor' });
    }
  }

  // Actualizar universidad
  static async actualizarUniversidad(req: AuthRequest, res: Response) {
    try {
      const { id } = req.params;
      const { nombre, codigo, tipo, ciudad, activa } = req.body;

      // Solo admins pueden actualizar universidades
      if (req.user?.rol !== RolUsuario.ADMIN) {
        return res.status(403).json({ 
          error: 'No tienes permisos para actualizar universidades' 
        });
      }

      if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({ error: 'ID de universidad inv√°lido' });
      }

      const universidad = await Universidad.findById(id);
      if (!universidad) {
        return res.status(404).json({ error: 'Universidad no encontrada' });
      }

      // Verificar c√≥digo √∫nico si se est√° cambiando
      if (codigo && codigo !== universidad.codigo) {
        const codigoExistente = await Universidad.findOne({ 
          codigo, 
          _id: { $ne: id } 
        });
        if (codigoExistente) {
          return res.status(400).json({ 
            error: 'Ya existe una universidad con este c√≥digo' 
          });
        }
      }

      // Guardar datos anteriores para auditor√≠a
      const datosAnteriores = {
        nombre: universidad.nombre,
        codigo: universidad.codigo,
        tipo: universidad.tipo,
        ciudad: universidad.ciudad,
        activa: universidad.activa
      };

      // Actualizar campos
      if (nombre) universidad.nombre = nombre;
      if (codigo) universidad.codigo = codigo;
      if (tipo) universidad.tipo = tipo;
      if (ciudad) universidad.ciudad = ciudad;
      universidad.activa = true; // Siempre activo

      await universidad.save();

      // Registrar en auditor√≠a
      await AuditLog.create({
        usuarioId: new mongoose.Types.ObjectId(req.user!.userId), // Cambiar 'usuario' por 'usuarioId'
        accion: AccionAudit.UPDATE, // Usar enum en lugar de string
        entidad: EntidadAudit.UNIVERSIDAD, // Usar enum en lugar de string
        entidadId: universidad._id.toString(),
        antes: datosAnteriores,
        despues: {
          nombre: universidad.nombre,
          codigo: universidad.codigo,
          tipo: universidad.tipo,
          ciudad: universidad.ciudad,
          activa: universidad.activa
        }
      });

      res.json({ 
        message: 'Colegio actualizado exitosamente',
        universidad 
      });
    } catch (error) {
      console.error('Error al actualizar universidad:', error);
      res.status(500).json({ error: 'Error interno del servidor' });
    }
  }

  // Eliminar universidad (soft delete)
  static async eliminarUniversidad(req: AuthRequest, res: Response) {
    try {
      const { id } = req.params;

      // Solo admins pueden eliminar universidades
      if (req.user?.rol !== RolUsuario.ADMIN) {
        return res.status(403).json({ 
          error: 'No tienes permisos para eliminar universidades' 
        });
      }

      if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({ error: 'ID de universidad inv√°lido' });
      }

      const universidad = await Universidad.findById(id);
      if (!universidad) {
        return res.status(404).json({ error: 'Universidad no encontrada' });
      }

      // Hard delete - eliminar f√≠sicamente de la base de datos
      const universidadData = {
        nombre: universidad.nombre,
        codigo: universidad.codigo,
        tipo: universidad.tipo,
        ciudad: universidad.ciudad,
        activa: universidad.activa
      };

      // Eliminar tambi√©n las titulaciones asociadas
      await Titulacion.deleteMany({ universidadId: universidad._id });
      
      // Eliminar la universidad
      await Universidad.findByIdAndDelete(id);

      // Registrar en auditor√≠a
      await AuditLog.create({
        usuarioId: new mongoose.Types.ObjectId(req.user!.userId),
        accion: AccionAudit.DELETE,
        entidad: EntidadAudit.UNIVERSIDAD,
        entidadId: universidad._id.toString(),
        antes: universidadData,
        despues: null // Ya no existe
      });

      res.json({ message: 'Colegio eliminado exitosamente' });
    } catch (error) {
      console.error('Error al eliminar universidad:', error);
      res.status(500).json({ error: 'Error interno del servidor' });
    }
  }

  // Buscar universidad por c√≥digo
  static async buscarPorCodigo(req: AuthRequest, res: Response) {
    try {
      const { codigo } = req.params;
      console.log('üîç buscarPorCodigo called with codigo:', codigo);
      console.log('üîç Codigo type:', typeof codigo);
      console.log('üîç Codigo after toUpperCase:', codigo.toUpperCase());
      
      const universidad = await Universidad.findOne({ 
        codigo: codigo.toUpperCase(),
        activa: true 
      });
      console.log('üè´ Universidad found by codigo:', universidad ? universidad.toObject() : 'null');
      
      if (!universidad) {
        console.log('‚ùå Universidad not found for codigo:', codigo);
        return res.status(404).json({ 
          success: false,
          message: 'Universidad no encontrada' 
        });
      }
      
      console.log('üì§ Sending universidad response:', {
        _id: universidad._id,
        codigo: universidad.codigo,
        nombre: universidad.nombre
      });
      
      res.json({
        success: true,
        data: {
          _id: universidad._id,
          codigo: universidad.codigo,
          nombre: universidad.nombre
        }
      });
    } catch (error: any) {
      console.error('‚ùå Error buscando universidad por c√≥digo:', error);
      console.error('‚ùå Error stack:', error.stack);
      res.status(500).json({ 
        success: false,
        message: 'Error interno del servidor' 
      });
    }
  }

  // Obtener universidades con titulaciones y estad√≠sticas de alumnos por curso
  // M√©todo auxiliar para obtener subordinados recursivamente
  // COMENTADO: Funci√≥n que usaba JerarquiaUsuarios (modelo eliminado)
  /*
  static async getSubordinados(jefeId: string): Promise<string[]> {
    const subordinadosDirectos = await JerarquiaUsuarios.find({ jefeId }).select('subordinadoId');
    let todosLosSubordinados = subordinadosDirectos.map(s => s.subordinadoId.toString());
    
    // Recursivamente obtener subordinados de subordinados
    for (const subordinadoId of subordinadosDirectos.map(s => s.subordinadoId.toString())) {
      const subSubordinados = await UniversidadesController.getSubordinados(subordinadoId);
      todosLosSubordinados = [...todosLosSubordinados, ...subSubordinados];
    }
    
    return [...new Set(todosLosSubordinados)];
  }
  */

  static async obtenerUniversidadesConEstadisticas(req: AuthRequest, res: Response) {
    try {
      console.log('üîç obtenerUniversidadesConEstadisticas called');
      
      const { activa = 'true' } = req.query;
      const userId = req.user?.userId;
      const userRole = req.user?.rol;
      
      let comercialesVisibles: string[];
      
      // Si es administrador, puede ver todos los comerciales
      if (userRole === 'ADMIN') {
        const todosLosUsuarios = await Usuario.find({ 
          rol: { $in: ['COMERCIAL', 'ADMIN'] },
          estado: 'ACTIVO' 
        }).select('_id');
        comercialesVisibles = todosLosUsuarios.map(u => u._id.toString());
        console.log(`üë• ADMIN - Comerciales visibles (todos):`, comercialesVisibles.length);
      } else {
         // COMENTADO: Funcionalidad de jerarqu√≠a temporalmente deshabilitada
         // Para comerciales, obtener subordinados del usuario actual
         if (!userId) {
           return res.status(401).json({
             success: false,
             message: 'Usuario no autenticado'
           });
         }
         // const subordinados = await UniversidadesController.getSubordinados(userId);
         // comercialesVisibles = [userId, ...subordinados];
         comercialesVisibles = [userId]; // Solo el usuario actual por ahora
         console.log(`üë• Comerciales visibles para ${userId}:`, comercialesVisibles);
       }
      
      // Obtener informaci√≥n de usuarios para las funciones jer√°rquicas
      const usuarios = await Usuario.find({ 
        rol: { $in: ['COMERCIAL', 'ADMIN'] },
        estado: 'ACTIVO' 
      }).select('_id nombre email rol');
      
      console.log('üë• Usuarios activos encontrados:');
      usuarios.forEach(u => {
        console.log(`   - ID: ${u._id}, Nombre: ${u.nombre}, Email: ${u.email}, Rol: ${u.rol}`);
      });
      
      // Obtener universidades activas
      const universidades = await Universidad.find({ activa: activa === 'true' })
        .sort({ nombre: 1 });
      
      console.log(`üìö Found ${universidades.length} universidades`);
      
      // Para cada universidad, obtener titulaciones y estad√≠sticas de contactos
      const universidadesConEstadisticas = await Promise.all(
        universidades.map(async (universidad) => {
          console.log(`üè´ Processing universidad: ${universidad.nombre}`);
          
          // Obtener titulaciones de la universidad
          const titulaciones = await Titulacion.find({ 
            universidadId: universidad._id,
            estado: 'activa'
          }).select('nombre codigo tipo duracion creditos modalidad descripcion');
          
          console.log(`üéì Found ${titulaciones.length} titulaciones for ${universidad.nombre}`);
          
          // Para cada titulaci√≥n, obtener estad√≠sticas de contactos por curso
          const titulacionesConEstadisticas = await Promise.all(
            titulaciones.map(async (titulacion) => {
              console.log(`üìä Processing titulacion: ${titulacion.nombre}`);
              
              // Obtener contactos de esta titulaci√≥n agrupados por curso (incluye usuario y subordinados)
              const contactosPorCurso = await Contacto.aggregate([
                {
                  $match: {
                    universidadId: universidad._id,
                    titulacionId: titulacion._id,
                    comercialId: { $in: comercialesVisibles.map(id => new mongoose.Types.ObjectId(id)) }
                  }
                },
                {
                  $lookup: {
                    from: 'usuarios',
                    localField: 'comercialId',
                    foreignField: '_id',
                    as: 'comercialInfo'
                  }
                },
                {
                  $unwind: {
                    path: '$comercialInfo',
                    preserveNullAndEmptyArrays: true
                  }
                },
                {
                  $group: {
                    _id: '$curso',
                    totalAlumnos: { $sum: 1 },
                    alumnos: {
                      $push: {
                        _id: '$_id',
                        nombreCompleto: '$nombreCompleto',
                        telefono: '$telefono',
                        instagram: '$instagram',
                        anioNacimiento: '$anioNacimiento',
                        fechaAlta: '$fechaAlta',
                        comercialId: '$comercialId',
                        comercialNombre: '$comercialInfo.nombre'
                      }
                    },
                    porComercial: {
                      $push: {
                        comercialId: '$comercialId',
                        comercialNombre: '$comercialInfo.nombre'
                      }
                    }
                  }
                },

                {
                  $sort: { _id: 1 } // Ordenar por curso
                }
              ]);
              
              console.log(`üë• Found contacts for ${titulacion.nombre}:`, contactosPorCurso.length, 'courses');

              // Check if titulacion has any contacts
const totalContactosTitulacion = contactosPorCurso.reduce((sum: number, curso: any) => sum + curso.totalAlumnos, 0);

if (totalContactosTitulacion === 0) {
  console.log(`‚è≠Ô∏è Skipping empty titulacion: ${titulacion.nombre}`);
  return {
    ...titulacion.toObject(),
    totalAlumnos: 0,
    cursos: Array.from({length: 6}, (_, i) => ({
      curso: i + 1,
      totalAlumnos: 0,
      alumnos: [],
      estadisticasPorComercial: {},
      comercialesInfo: {}
    })),
    estadisticasPorComercial: {},
    comercialesInfo: {}
  };
}

/*
// Create hierarchy cache once at the beginning
const jerarquiaCache = new Map<string, string>();
const todasLasJerarquias = await JerarquiaUsuarios.find({
  subordinadoId: { $in: comercialesVisibles.map(id => new mongoose.Types.ObjectId(id)) }
});

todasLasJerarquias.forEach(relacion => {
  if (relacion.jefeId) {
    jerarquiaCache.set(relacion.subordinadoId.toString(), relacion.jefeId.toString());
  }
});

console.log('üó∫Ô∏è Jerarqu√≠a cache creado:', jerarquiaCache.size, 'relaciones');
              
              // Crear mapa de jerarqu√≠a para agregar contactos de subordinados a sus jefes
              const jerarquiaMap = new Map<string, string>();
              console.log('üîç Construyendo jerarquiaMap para comerciales visibles:', comercialesVisibles);
              
              for (const comercialId of comercialesVisibles) {
                if (typeof comercialId === 'string') {
                  const relacion = await JerarquiaUsuarios.findOne({ subordinadoId: comercialId });
                  console.log(`üîç Buscando jerarqu√≠a para comercialId ${comercialId}:`, relacion ? 'ENCONTRADA' : 'NO ENCONTRADA');
                  if (relacion && relacion.jefeId) {
                    const jefeIdStr = (relacion.jefeId as any).toString();
                    console.log(`üîç Jefe encontrado para ${comercialId}: ${jefeIdStr}`);
                    if (comercialesVisibles.includes(jefeIdStr)) {
                      jerarquiaMap.set(comercialId, jefeIdStr);
                      console.log(`‚úÖ Jerarqu√≠a agregada: ${comercialId} -> ${jefeIdStr}`);
                    } else {
                      console.log(`‚ùå Jefe ${jefeIdStr} no est√° en comerciales visibles`);
                    }
                  }
                }
              }
              
              console.log('üó∫Ô∏è JerarquiaMap final:', Array.from(jerarquiaMap.entries()));
              
              // Funci√≥n para agregar estad√≠sticas jer√°rquicamente
              const agregarEstadisticasJerarquicas = (estadisticas: { [key: string]: number }, comercialesInfo: { [key: string]: string }) => {
                const estadisticasFinales: { [key: string]: number } = {};
                const comercialesInfoFinales: { [key: string]: string } = {};
                
                // Primero, copiar todas las estad√≠sticas directas
                Object.keys(estadisticas).forEach(comercialId => {
                  estadisticasFinales[comercialId] = estadisticas[comercialId];
                  if (comercialesInfo[comercialId]) {
                    comercialesInfoFinales[comercialId] = comercialesInfo[comercialId];
                  }
                });
                
                // Luego, agregar estad√≠sticas de subordinados a sus jefes
                Object.keys(estadisticas).forEach(comercialId => {
                  const jefeId = jerarquiaMap.get(comercialId);
                  if (jefeId && jefeId !== comercialId) {
                    estadisticasFinales[jefeId] = (estadisticasFinales[jefeId] || 0) + estadisticas[comercialId];
                    // Mantener info del jefe si existe
                    if (comercialesInfo[jefeId]) {
                      comercialesInfoFinales[jefeId] = comercialesInfo[jefeId];
                    }
                  }
                });
                
                return { estadisticasFinales, comercialesInfoFinales };
              };
              
              // Funci√≥n auxiliar para verificar si un usuario es ficticio
              const esUsuarioFicticio = (usuario: any) => {
                if (!usuario) return false;
                return usuario.nombre.toLowerCase().includes('ensalada') || 
                       usuario.nombre.toLowerCase().includes('cesar') ||
                       usuario.email.includes('adaasdasdaministrador');
              };
              
              // Funci√≥n auxiliar para encontrar el jefe real m√°s cercano en la cadena jer√°rquica
              const encontrarJefeReal = (comercialId: string, visitados = new Set<string>()): string | null => {
                // Evitar bucles infinitos
                if (visitados.has(comercialId)) return null;
                visitados.add(comercialId);
                
                const usuario = usuarios.find(u => u._id.toString() === comercialId);
                
                // Si el usuario no existe o no es ficticio, es el jefe real
                if (!usuario || !esUsuarioFicticio(usuario)) {
                  return comercialId;
                }
                
                // Si es ficticio, buscar su jefe
                const jefeId = jerarquiaMap.get(comercialId);
                if (jefeId && jefeId !== comercialId) {
                  return encontrarJefeReal(jefeId, visitados);
                }
                
                return null;
              };

              // Funci√≥n para agregar alumnos jer√°rquicamente
              const agregarAlumnosJerarquicos = (alumnos: any[]) => {
                const alumnosFinales: any[] = [];
                console.log('üéì Procesando alumnos para reasignaci√≥n jer√°rquica:', alumnos.length);
                
                // Para cada alumno, determinar si debe mostrarse como del comercial original o del jefe real
                alumnos.forEach(alumno => {
                  const comercialId = alumno.comercialId?.toString();
                  
                  console.log(`üéì Procesando alumno ${alumno.nombreCompleto}:`);
                  console.log(`   - ComercialId original: ${comercialId}`);
                  
                  // Encontrar el jefe real m√°s cercano en la cadena jer√°rquica
                  const jefeRealId = encontrarJefeReal(comercialId);
                  
                  console.log(`   - Jefe real encontrado: ${jefeRealId}`);
                  
                  if (jefeRealId && jefeRealId !== comercialId) {
                    const jefeUsuario = usuarios.find(u => u._id.toString() === jefeRealId);
                    
                    if (jefeUsuario) {
                      console.log(`   ‚úÖ REASIGNANDO a jefe real: ${jefeUsuario.nombre}`);
                      // Mostrar el alumno asignado al jefe real
                      const alumnoParaJefe = {
                        ...alumno,
                        comercialId: jefeRealId,
                        comercialNombre: jefeUsuario.nombre
                      };
                      alumnosFinales.push(alumnoParaJefe);
                    } else {
                      console.log(`   ‚ùå Jefe real no encontrado - manteniendo original`);
                      alumnosFinales.push(alumno);
                    }
                  } else {
                    console.log(`   ‚ùå No hay reasignaci√≥n necesaria - manteniendo original`);
                    // Mostrar el alumno con su comercial original
                    alumnosFinales.push(alumno);
                  }
                });
                
                console.log('üéì Alumnos finales despu√©s de reasignaci√≥n:', alumnosFinales.length);
                return alumnosFinales;
              };
*/

              // NUEVO: Crear estructura completa de cursos (1-6) incluso si est√°n vac√≠os
              const cursosCompletos: any[] = [];
              for (let cursoNum = 1; cursoNum <= 6; cursoNum++) {
                const cursoData = contactosPorCurso.find(c => c._id === cursoNum);
                
                // Calcular estad√≠sticas por comercial para este curso
                const estadisticasPorComercial: { [key: string]: number } = {};
                const comercialesInfo: { [key: string]: string } = {};
                
                if (cursoData && cursoData.porComercial) {
                  cursoData.porComercial.forEach((item: any) => {
                    const comercialId = item.comercialId.toString();
                    estadisticasPorComercial[comercialId] = (estadisticasPorComercial[comercialId] || 0) + 1;
                    if (item.comercialNombre) {
                      comercialesInfo[comercialId] = item.comercialNombre;
                    }
                  });
                }
                
                // Aplicar agregaci√≥n jer√°rquica
                // Simplified: Direct assignment instead of hierarchical processing
                const estadisticasFinales = estadisticasPorComercial;
                const comercialesInfoFinales = comercialesInfo;
                
                // Filtrar comerciales a mostrar (solo los que no son subordinados de otros en la lista visible, o el usuario actual)
                const comercialesCursoAMostrar: { [key: string]: number } = {};
                const comercialesInfoCursoAMostrar: { [key: string]: string } = {};
                
                Object.keys(estadisticasFinales).forEach(comercialId => {
                  const esSubordinado = false; // Simplified: no hierarchy system
                  // Para administradores, mostrar todos los comerciales (incluyendo jefes con estad√≠sticas agregadas)
                  // Para comerciales, solo mostrar los que no son subordinados o el usuario actual
                  if (userRole === 'ADMIN' || !esSubordinado || comercialId === userId) {
                    comercialesCursoAMostrar[comercialId] = estadisticasFinales[comercialId];
                    if (comercialesInfoFinales[comercialId]) {
                      comercialesInfoCursoAMostrar[comercialId] = comercialesInfoFinales[comercialId];
                    }
                  }
                });
                
                // Aplicar agregaci√≥n jer√°rquica a los alumnos
                // Simplified: No hierarchy processing
                const alumnos = cursoData ? cursoData.alumnos || [] : [];
                const alumnosConJerarquia = alumnos;
                
                cursosCompletos.push({
                  curso: cursoNum,
                  totalAlumnos: cursoData ? cursoData.totalAlumnos : 0,
                  alumnos: alumnosConJerarquia,
                  estadisticasPorComercial: comercialesCursoAMostrar,
                  comercialesInfo: comercialesInfoCursoAMostrar
                });
              }
              
              // Calcular estad√≠sticas generales por comercial para toda la titulaci√≥n
              const estadisticasGeneralesPorComercial: { [key: string]: number } = {};
              const comercialesInfoGeneral: { [key: string]: string } = {};
              
              cursosCompletos.forEach(curso => {
                Object.keys(curso.estadisticasPorComercial).forEach(comercialId => {
                  estadisticasGeneralesPorComercial[comercialId] = (estadisticasGeneralesPorComercial[comercialId] || 0) + curso.estadisticasPorComercial[comercialId];
                  if (curso.comercialesInfo[comercialId]) {
                    comercialesInfoGeneral[comercialId] = curso.comercialesInfo[comercialId];
                  }
                });
              });
              
              // Aplicar agregaci√≥n jer√°rquica
              // Simplified: Direct assignment instead of hierarchical processing
              const estadisticasFinales = estadisticasGeneralesPorComercial;
              const comercialesInfoFinales = comercialesInfoGeneral;
              
              // Filtrar comerciales a mostrar (solo los que no son subordinados de otros en la lista visible, o el usuario actual)
              const comercialesAMostrar: { [key: string]: number } = {};
              const comercialesInfoAMostrar: { [key: string]: string } = {};
              
              Object.keys(estadisticasFinales).forEach(comercialId => {
                const esSubordinado = false; // Simplified: no hierarchy system
                // Para administradores, mostrar todos los comerciales (incluyendo jefes con estad√≠sticas agregadas)
                // Para comerciales, solo mostrar los que no son subordinados o el usuario actual
                if (userRole === 'ADMIN' || !esSubordinado || comercialId === userId) {
                  comercialesAMostrar[comercialId] = estadisticasFinales[comercialId];
                  if (comercialesInfoFinales[comercialId]) {
                    comercialesInfoAMostrar[comercialId] = comercialesInfoFinales[comercialId];
                  }
                }
              });
              
              // Calcular total de alumnos en la titulaci√≥n
              const totalAlumnosTitulacion = cursosCompletos.reduce(
                (sum, curso) => sum + curso.totalAlumnos, 0
              );
              
              return {
                ...titulacion.toObject(),
                totalAlumnos: totalAlumnosTitulacion,
                cursos: cursosCompletos,
                estadisticasPorComercial: comercialesAMostrar,
                comercialesInfo: comercialesInfoAMostrar
              };
              })
            );
            
            // Calcular total de alumnos en la universidad
            const totalAlumnosUniversidad = titulacionesConEstadisticas.reduce(
              (sum, tit) => sum + tit.totalAlumnos, 0
            );
            
            console.log(`üìà Total alumnos for ${universidad.nombre}: ${totalAlumnosUniversidad}`);
            
            return {
              ...universidad.toObject(),
              totalAlumnos: totalAlumnosUniversidad,
              totalTitulaciones: titulacionesConEstadisticas.length,
              titulaciones: titulacionesConEstadisticas
            };
          })
        );
        
        // Calcular estad√≠sticas generales
        const estadisticasGenerales = {
          totalUniversidades: universidadesConEstadisticas.length,
          totalTitulaciones: universidadesConEstadisticas.reduce(
            (sum, uni) => sum + uni.totalTitulaciones, 0
          ),
          totalAlumnos: universidadesConEstadisticas.reduce(
            (sum, uni) => sum + uni.totalAlumnos, 0
          )
        };
        
        console.log('üìä Estad√≠sticas generales:', estadisticasGenerales);
        
        res.json({
          success: true,
          estadisticasGenerales,
          universidades: universidadesConEstadisticas
        });
        
      } catch (error: any) {
        console.error('‚ùå Error al obtener universidades con estad√≠sticas:', error);
        console.error('‚ùå Error stack:', error.stack);
        res.status(500).json({ 
          success: false,
          error: 'Error interno del servidor' 
        });
      }
    }

    // Normalizar localidades de universidades
    static async normalizarLocalidadesUniversidades(req: AuthRequest, res: Response) {
      try {
        // Solo admins pueden normalizar localidades
        if (req.user?.rol !== RolUsuario.ADMIN) {
          return res.status(403).json({ 
            error: 'No tienes permisos para normalizar localidades de universidades' 
          });
        }

        console.log('üîç Iniciando normalizaci√≥n de localidades de universidades...');
        
        // Obtener todas las universidades
        const universidades = await Universidad.find({});
        console.log(`üìä Total de universidades encontradas: ${universidades.length}`);
        
        // Mostrar algunos ejemplos de localidades actuales
        const ejemplosLocalidades = universidades.slice(0, 5).map(u => ({
          nombre: u.nombre,
          ciudad: u.ciudad,
          ciudadNormalizada: UniversidadesController.normalizeNameWithCapitalization(u.ciudad || '')
        }));
        console.log('üìã Ejemplos de localidades a procesar:', ejemplosLocalidades);
        
        let universidadesActualizadas = 0;
        let errores = 0;
        const cambios: Array<{universidadId: string, localidadAnterior: string, localidadNueva: string}> = [];
        
        for (const universidad of universidades) {
          try {
            const localidadAnterior = universidad.ciudad || '';
            const localidadNormalizada = UniversidadesController.normalizeNameWithCapitalization(localidadAnterior);
            
            // Solo actualizar si la localidad cambi√≥ al normalizar
            if (localidadAnterior !== localidadNormalizada && localidadNormalizada !== '') {
              console.log(`üîÑ Normalizando localidad: "${localidadAnterior}" ‚Üí "${localidadNormalizada}"`);
              
              universidad.ciudad = localidadNormalizada;
              await universidad.save();
              
              universidadesActualizadas++;
              cambios.push({
                universidadId: universidad._id.toString(),
                localidadAnterior,
                localidadNueva: localidadNormalizada
              });
            } else {
              // No es un error, simplemente no necesita normalizaci√≥n
              console.log(`‚úÖ Universidad ${universidad.nombre} ya est√° normalizada: "${localidadAnterior}"`);
            }
          } catch (error) {
            console.error(`‚ùå Error normalizando universidad ${universidad._id}:`, error);
            errores++;
          }
        }
        
        console.log(`‚úÖ Normalizaci√≥n de localidades completada: ${universidadesActualizadas} universidades actualizadas, ${errores} errores`);
        
        // Registrar en auditor√≠a
        await AuditLog.create({
          usuarioId: new mongoose.Types.ObjectId(req.user!.userId),
          accion: AccionAudit.UPDATE,
          entidad: EntidadAudit.UNIVERSIDAD,
          entidadId: 'BULK_LOCALIDAD_NORMALIZATION',
          despues: {
            accion: 'NORMALIZACION_MASIVA_LOCALIDADES_UNIVERSIDADES',
            universidadesActualizadas,
            errores,
            cambios: cambios.slice(0, 10) // Solo los primeros 10 cambios en el log
          }
        });

        res.json({
          success: true,
          message: 'Normalizaci√≥n de localidades completada',
          universidadesActualizadas,
          errores,
          totalUniversidades: universidades.length
        });
      } catch (error) {
        console.error('Error normalizando localidades de universidades:', error);
        res.status(500).json({ 
          success: false,
          error: 'Error interno del servidor' 
        });
      }
    }
}